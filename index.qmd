---
title: Moju Kapu モジュカプ
subtitle: How `mirai` and `crew` Are Powering the Next Generation of Parallel Computing in R
author: Charlie Gao and Will Landau
institute: Hibiki AI Limited, Eli Lilly and Company
date: July 9, 2024
format:
    revealjs:
        theme:
            - custom.scss
        incremental: true
        footer: "slides available at https://shikokuchuo.net/user2024-conference"
        embed-resources: true
        slide-number: true
editor:
    render-on-save: true
---

<style>
h1 {
  font-size: 1.6em !important;
}
h2 {
  font-size: 1.4em !important;
}
</style>

# mirai

## 未来
::: {.nonincremental}

みらい &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / mI ˈ ra ˈ i: /


n. future
:::

![](images/mirai.png)

##

```{.r code-line-numbers="|7-10|3-4,11|6-12|14-15|17-18|20-21|23-25"}
library(mirai)

a <- 1
b <- 2

m <- mirai(
  {
    Sys.sleep(5)
    a + b
  },
  environment()
)

m
#> < mirai | $data >

m$data
#> 'unresolved' logi NA

m[]
#> [1] 3

m$data
#> [1] 3
```

## {.center}

But what's so special about this? ...

. . .

::: {.nonincremental}
1. Highly performant
2. Simple and robust
3. Designed for production
:::

## Integration with Base R

Request by R Core (Luke Tierney) at R Project Sprint 2023

* `mirai` added as the first alternative communications backend for the base `parallel` package

. . .

```{.r}
library(parallel)

cl <- mirai::make_cluster(2)
cl
#> < miraiCluster | ID: `0` nodes: 2 active: TRUE >

parLapply(cl, 1:2, rnorm)
#> [[1]]
#> [1] -0.5697883
#> 
#> [[2]]
#> [1] 0.3798926 0.8945085

```

## Integration with Shiny

```{.r code-line-numbers="8,13-17,21"}
library(shiny)
library(bslib)
library(mirai)

ui <- page_fluid(
  numericInput("n", "Sample size (n)", 100),
  numericInput("delay", "Seconds to take for plot", 5),
  input_task_button("btn", "Plot uniform distribution"),
  plotOutput("plot")
)

server <- function(input, output, session) {
  task <- ExtendedTask$new(
    function(...) mirai({Sys.sleep(y); runif(x)}, ...)
  ) |> bind_task_button("btn")
  observeEvent(input$btn, task$invoke(x = input$n, y = input$delay))
  output$plot <- renderPlot(hist(task$result()))
}

app <- shinyApp(ui = ui, server = server)
with(daemons(3), runApp(app))
```

## Integration with Plumber

```{.r}
library(plumber)
library(promises)
library(mirai)

pr() |>
  pr_get(
    "/echo",
    function(req, res) {
      mirai(
        list(status = 200L, body = list(msg = msg)),
        msg = req[["HEADERS"]][["msg"]]
      ) %...>% (function(x) {
          res$status <- x$status
          res$body <- x$body
        })
    }
  ) |>
  pr_run(host = "127.0.0.1", port = 8985)
```


# crew

---

## Re-encapsulating `mirai`

<center>
<img src="./images/crew.png" width=400>
</center>

---

## Why `crew`?

<center>
<img src="./images/crew-package-row.png" width=700>
</center>

<ul style="font-size: 30px">
  <li>Extends <code>mirai</code> to distributed computing environments.</li>
  <li>Centralized <code>R6</code> interface for tasks.</li>
  <li>Worker auto-scaling to respond fluctuating task loads.</li>
</ul>

## Moju Kapu in `crew`

.pull-left[

### Encapsulation

<center>
<img src="./images/crew-core.png" width=250>
</center>

* Uses `mirai` developer interface: `daemon()`, `nextget()`, `saisei()` etc.
* `R6` class system for the controller interface.

]

.pull-right[

### Modularity

<center>
<img src="./images/crew-plugins.png" width=250>
</center>

* Plugin system to launch parallel workers on different environments.
* Docs guide users to write their own plugins.
* Existing encapsulated plugins for SLURM, AWS Batch, etc.

]

## `R6` classes

| **Class** | **About** | 
|---|---|
| **Controller group** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Interface for many controllers. |
| **Controller** | Central task interface. |
| **Tasks** | List of `mirai` task objects. | 
| **Client** | `mirai` TCP connection hub. |
| **Relay** | Coordinate `mirai` synchronization primitives. |
| **Launcher** | Launches workers. Subclasses for plugins. |
| **Async** | Parallelize worker launches. |

## `R6` object composition

<center>
<img src="./images/crew-design.png" width=400>
</center>

## `mirai` tasks, different interface

```{r, eval = FALSE}
# Start a controller.
library(crew)
controller <- crew_controller_local(
  workers = 2,
  seconds_idle = 10
)
controller$start()

# Submit tasks asynchronously.
controller$push(command = 1 + 1)
controller$push(command = sqrt(9))

# Wait for a task to finish.
controller$wait(mode = "one")

# Collect the result.
controller$pop()$result[[1]]
#> [1] 3
```

## Different plugin, different controller

```{r, eval = FALSE}
# Start an AWS Batch controller with many workers.
library(crew.aws.batch)
controller <- crew_controller_aws_batch(
  workers = 100,
  seconds_idle = 60,
  aws_batch_job_definition = "YOUR_JOB_DEFINITION",
  aws_batch_job_queue = "YOUR_JOB_QUEUE"
)
controller$start()

# Submit many tasks asynchronously.
controller$walk(
  command = your_expensive_task(data = object),
  iterate = list(object = list_of_objects),
  data = list(expensive_task = expensive_task)
)
```

## Write your own launcher plugin

* Tutorial to write plugins: <https://wlandau.github.io/crew/articles/plugins.html>

```{r, eval = FALSE}
custom_launcher_class <- R6::R6Class(
  classname = "custom_launcher_class",
  inherit = crew::crew_class_launcher,
  public = list(
    launch_worker = function(call, name, launcher, worker, instance) { #<<
      bin <- file.path(R.home("bin"), "R")
      processx::process$new(
        command = bin,
        args = c("-e", call),
        cleanup = FALSE
      )
    },
    terminate_worker = function(handle) { #<<
      handle$signal(crew::crew_terminate_signal())
    }
  )
)
```

## Controller wrapper

* Tutorial to write plugins: <https://wlandau.github.io/crew/articles/plugins.html>

```{r, eval = FALSE}
#' @title Create a controller with the custom launcher.
#' @export
#' @description Create an `R6` object to submit tasks and
#'   launch workers.
#' @inheritParams crew::crew_controller_local
crew_controller_custom <- function(...) {
  client <- crew::crew_client(...)
  launcher <- custom_launcher_class$new(...) #<<
  controller <- crew::crew_controller(client = client, launcher = launcher) #<<
  controller$validate()
  controller
}
```

